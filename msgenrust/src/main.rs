// Import necessary crates and modules
use sha2::{Sha256, Digest};
use std::env;
use std::io::Write;
use std::process::{Command, Stdio};

// Function to validate and convert the second argument (depth) to an integer
fn validate_depth(arg_two: &str) -> i32 {
    // Try to parse the argument as an integer
    if let Ok(n) = arg_two.parse::<i32>() {
        return n;
    }
    // If that fails, try to parse it as a float and round to the nearest integer
    if let Ok(test_float) = arg_two.parse::<f64>() {
        return test_float.round() as i32;
    }
    // If both parsing attempts fail, return 0
    0
}

// Function to validate command line arguments and extract necessary information
fn validate_args(args: &[String]) -> (String, i32, bool) {
    // If only one argument is provided (the text to hash)
    if args.len() == 2 {
        (args[1].clone(), 1, true)
    // If two arguments are provided and the second one is a valid depth
    } else if args.len() >= 3 && validate_depth(&args[2]) > 0 {
        (args[1].clone(), validate_depth(&args[2]), true)
    // If the second argument is provided but is not a valid depth
    } else if args.len() > 2 && validate_depth(&args[2]) == 0 {
        ("Invalid depth supplied! Program will terminate here!".to_string(), 0, false)
    // If no valid depth is provided with the text
    } else if args.len() == 2 {
        ("No depth has been supplied! Program will terminate here!".to_string(), 0, false)
    } else {
        ("".to_string(), 0, false)
    }
}

// Function to hash the input string using SHA-256
fn crunch(mstr: &str) -> String {
    let mut hasher = Sha256::new();
    // Remove any leading/trailing whitespace and update the hasher
    hasher.update(mstr.trim().as_bytes());
    // Finalize the hash and format it as a hexadecimal string
    let result = hasher.finalize();
    format!("{:x}", result)
}

// Function to copy the given content to the clipboard using xclip
fn copy_to_clipboard(content: &str) {
    // Create a new xclip command to copy to the clipboard
    let mut cmd = Command::new("xclip")
        .arg("-selection")
        .arg("clipboard")
        .stdin(Stdio::piped())
        .spawn()
        .expect("Failed to start xclip");

    {
        // Open the stdin of the xclip command and write the content to it
        let stdin = cmd.stdin.as_mut().expect("Failed to open stdin");
        stdin.write_all(content.as_bytes()).expect("Failed to write to stdin");
    }

    // Wait for the xclip command to complete
    let output = cmd.wait_with_output().expect("Failed to wait on xclip");
    // If the command did not succeed, print an error message
    if !output.status.success() {
        eprintln!("xclip command failed with status: {}", output.status);
    }
}

// Main function to execute the program
fn main() {
    // Collect command line arguments
    let args: Vec<String> = env::args().collect();

    // Define constants for help, documentation, and version messages
    const HELP: &str = "usage: 

    ./msgenrust -flag
    
    list of flags:
    
    -d: docs
    -h: list of flags
    -v: version";


    const DOC: &str = "# SHA256 Master Password Generator

    A password generator using the SHA256 hash function. Currently a password generated by this hash function would be prohibitively difficult for virtually any entity to attack.
    
    ---
    
    ## Licence
    
    // SPDX-License-Identifier: MIT  
    Copyright (c) 2022 [Joseph Anthony Debono](joe@jadebono.com)
    
    ---
    
    ## To Run
    
    First compile
    
    bash:
    # the path should be within the usual Go folder setup in src/github.com/user/target
    go mod init go/src/github.com/YOUR_USERNAME/mastergen
    go mod tidy
    # When you are ready to compile. (Note you can build for other architectures as well)
    go build
    # To run the compiled file.
    ./mastergen seedPhrase depth
    
    
    ## Purpose
    
    Good password praxis generally recommends a password of very high entropy for every one of your accounts. A password manager can generate as many highly entropic passwords of significant length as necessary.
    
    However, passwords managers have a glaring vulnerability - they themselves require a master password. Unfortunately, most people generally use passwords that are easy to remember and to type, making them low entropy, and vulnerable to attack in a number of ways, thus vitiating the strength of the passwords protected by your password manager.
    
    Solution: Use a sha256 hash function to generate the master password for the password manager. A hash produced by such a function not only has very high entropy, but it is deterministic, meaning that you can generate it at will as long as you have access to the hash function. This will provide you with a password that you will not remember so is impervious to social engineering attacks. However, you will still be able to generate it easily at any time you need it using simple and memorable phrase and depth inputs.
    
    ---
    
    ## Using the Generator
    
    1. Input a string in the phrase field. This can be any phrase you like. Since this will be hashed, it will not be your password, but its seed, so you are free to use any character/word/phrase you can remember easily. It does not matter how simple the phrase is because it will be run through the hash function the number of times specified by the depth. For example, using 'a' as your phrase with a depth of 10 will generate the following hash as your password: '389acb1da3cc19ae115c89eec398f9f2d2f3d961ff23a76decda54bf9660fac5'.
    
    1. Depth is the number of times you want to run the phrase through the hash function and then run the resultant hash back through the hash function. This will give you protection against brute force attempts using the hash function if the attacker suspects the use of one. Even if the attacker guesses the phrase, he will have no idea of the depth, leaving your security intact.
    
    **Example - Phrase: bird, Depth: 7**
    
    The generated password is the **seventh** hash of this process.
    
    0. bird
    1. 7a5179eecc0fe18760ba615f92603372ae3fe302860098a019e15927551fee3b
    2. 1467d232075b693bd528521179679ec07a083e4f0076ecd2af61607d6b5b2b38
    3. 282cf0b370024ec7f617ecc43e57bea2f748b7ea6b22b52ae09cfe997513851b
    4. 1d7532e421b85bb72b5d42d2c3aa2f526a5b8204950c02e2949b9ed39d35ea54
    5. a455a212dde0f7051228efc31bb03fef5d20761812cf79bbc198d397f718761e
    6. c7cc84962be268d578079c3e13694a9230de992f8186c53bc961376705922635
    7. 91c2b32ead801dc707c24b022b8497ca0f0ee2afaf13c6c88dc290a594289d95
    
    Your generated password is: 91c2b32ead801dc707c24b022b8497ca0f0ee2afaf13c6c88dc290a594289d95
    
    Note: mastergen has been tested to a depth of 1e10, taking about 110 seconds to generate the output.
    
    ---
    
    ## Further Notes
    
    1. Both the phrase and depth fields are inputs of type='password' to hide the inputs from onlookers.
    2. Leaving the depth field blank will submit your phrase through the hash function ONCE.
    3. Although you should provide nothing but an integer for depth, input validation has been implemented forthis field with the following results:
       i. Leaving the depth field blank => Depth is set to 1 (i.e. the phrase will be hashed ONCE);
       ii. Inputting an float into the depth field => Depth is set to the float rounded to an integer (ex: 3.2 => 3, 4.8 => 5).
    
    ---
    ";
    const VERSION: &str = "msgenrust current version: 0.1v";

    // If no arguments are provided, print a message and terminate
    if args.len() == 1 {
        println!("Neither seed phrase nor depth nor flag has been supplied! Program will terminate here!\nFor help, run mastergen with one of these flags:\n{}", HELP);
    // If arguments are provided, process them
    } else if args.len() > 1 {
        match args[1].as_str() {
            "-d" => println!("{}", DOC),      // Print documentation
            "-v" => println!("{}", VERSION),  // Print version information
            "-h" => println!("{}", HELP),     // Print help message
            _ => {
                // Validate the arguments and get the text, depth, and result flag
                let (mstr, n, result) = validate_args(&args);
                // If the validation fails, print the error message
                if !result {
                    println!("{}", mstr);
                } else {
                    // If validation succeeds, hash the text n times
                    let mut mstr = mstr;
                    for _ in 1..=n {
                        mstr = crunch(&mstr);
                    }
                    // Copy the final hash to the clipboard
                    copy_to_clipboard(&mstr);
                    // Print a confirmation message to the terminal
                    println!("Master password generated and copied to clipboard.");
                }
            }
        }
    }
}
